// src/game/combat/threat.ts
import {
  HEALING_THREAT_MULTIPLIER,
  MELEE_AGGRO_THRESHOLD,
  RANGED_AGGRO_THRESHOLD,
} from "@shared/constants";

/**
 * Threat modifiers applied to damage-based threat.
 */
export interface ThreatModifiers {
  stanceModifier: number; // e.g. 1.3 for defensive stance
  talentModifier: number; // e.g. 0.7 for threat reduction talent
  abilityModifier: number; // e.g. 1.5 for high-threat ability
}

/**
 * Calculate threat generated by dealing damage.
 *
 * Formula:
 * damage * stanceModifier * talentModifier * abilityModifier
 *
 * Modifiers are multiplicative.
 */
export function calculateDamageThreat(
  damage: number,
  mods: ThreatModifiers
): number {
  return damage * mods.stanceModifier * mods.talentModifier * mods.abilityModifier;
}

/**
 * Calculate threat generated by healing.
 *
 * Formula:
 * totalHeal * 0.5 / numberOfEnemies
 *
 * Healing threat is split evenly among all enemies in combat.
 */
export function calculateHealingThreat(
  totalHeal: number,
  enemyCount: number
): number {
  if (enemyCount === 0) return 0;
  return (totalHeal * HEALING_THREAT_MULTIPLIER) / enemyCount;
}

/**
 * Check if aggro should transfer from current target to attacker.
 *
 * Thresholds:
 * - Melee: Requires 110% of current target's threat
 * - Ranged: Requires 130% of current target's threat
 *
 * Returns true if attacker should gain aggro.
 */
export function shouldTransferAggro(
  attackerThreat: number,
  currentTargetThreat: number,
  isRanged: boolean
): boolean {
  const threshold = isRanged ? RANGED_AGGRO_THRESHOLD : MELEE_AGGRO_THRESHOLD;
  return attackerThreat >= currentTargetThreat * threshold;
}

/**
 * Threat table tracks threat values for all source/target pairs.
 *
 * Key format: "sourceId:targetId"
 */
export class ThreatTable {
  private threat: Map<string, number>;

  constructor() {
    this.threat = new Map();
  }

  /**
   * Generate key for source/target pair.
   */
  private getKey(sourceId: number, targetId: number): string {
    return `${sourceId}:${targetId}`;
  }

  /**
   * Add threat to a source/target pair.
   * Can be negative to reduce threat.
   */
  addThreat(sourceId: number, targetId: number, amount: number): void {
    const key = this.getKey(sourceId, targetId);
    const current = this.threat.get(key) ?? 0;
    this.threat.set(key, current + amount);
  }

  /**
   * Get current threat for a source/target pair.
   * Returns 0 if no threat exists.
   */
  getThreat(sourceId: number, targetId: number): number {
    const key = this.getKey(sourceId, targetId);
    return this.threat.get(key) ?? 0;
  }

  /**
   * Get the source with the highest threat against a target.
   * Returns null if no threat entries exist for this target.
   */
  getTopThreat(targetId: number): { sourceId: number; threat: number } | null {
    let topSource: number | null = null;
    let topThreat = -Infinity;

    for (const [key, threat] of this.threat.entries()) {
      const [sourceIdStr, targetIdStr] = key.split(":");
      const parsedTargetId = parseInt(targetIdStr, 10);

      if (parsedTargetId === targetId && threat > topThreat) {
        topThreat = threat;
        topSource = parseInt(sourceIdStr, 10);
      }
    }

    if (topSource === null) return null;

    return {
      sourceId: topSource,
      threat: topThreat,
    };
  }

  /**
   * Reset all threat values.
   */
  reset(): void {
    this.threat.clear();
  }
}
